---
title: "Pulsed-SILAC data analysis"
author: 
    name: "Marc PagÃ¨s-Gallego"
    affiliation: University Medical Center Utrecht, the Netherlands
date: "`r Sys.Date()`"
bibliography: 'bibliography.bib'
nocite: '@*'
abstract: "This document will contain a tutorial on how to perform basic pulsed SILAC data analysis using the pulsedSilac package."
output:
  BiocStyle::html_document:
    toc_float: true
  pdf_document: default
vignette: >
  %\VignetteIndexEntry{Pulsed-SILAC data analysis}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

# Introduction

SILAC (Stable Isotope Label by Amino acids in Cell culture) is a method to differentially compare protein expression between samples. To measure protein turnover, the SILAC technique is applied over time by changing the medium and harvesting the cells at different time points. Each sample is then be analyzed by mass spectrometry. The isotope ratio at each time point can then be used to calculate the turnover rate of each measured protein. This package contains a set of functions to analyze pulsed SILAC quantitative data.

ADD IMAGE

Functions are provided to organize the data, calculate isotope ratios/fractions, estimate cell growth, model protein turnover, compare turnover models and estimate isotope recycling. Several visualization tools are also included to explore the results: isotope incorporation, overall proteome turnover, individual protein/peptide models, comparison of turnover and expression.

# Data organization

Many Bioconductor packages use `SummarizedExperiment` objects or derivatives from it as input and/or output. This is a rectangular class of object that contains assays (matrix-like organized data) in which rows represent features (genes, proteins, metabolites, ...) and columns represent samples. Features are described in the `rowData` slot and samples are described in the `colData` slot, both contain data frames that fit with the dimensions of the assays. If you are unfamiliar with this format, please read this introductory [vignette](https://bioconductor.org/packages/3.8/bioc/vignettes/SummarizedExperiment/inst/doc/SummarizedExperiment.html).

ADD IMAGE

This package uses three `SummarizedExperiment` derived classes: `ProteinExperiment`, `PeptideExperiment` and `ProteomicsExperiment`.

## `ProteinExperiment` and `PeptideExperiment`

The `ProteinExperiment` and `PeptideExperiment` are, as their name indicates, to store either protein or peptide related data. These two objects are almost identical to a `SummarizedExperiment` object. Their only difference is the addition of a new slot called `metaoptions`. This slot contains a name `list` which contains values that are indicative of where certain information, required for the analysis, is located in the object. For example, the `conditionCol` value is used to indicate which column of `colData` has the information about the different experiment conditions.

### Object construction

Constructing a `ProteinExperiment` or a `PeptideExperiment` is extremely similar to constructing a `SummarizedExperiment`. The only additional arguments are the different `metaoptions` values. 

Here is an example of constructing a `ProteinExperiment`:

```{r}

require(pulsedSilac)
## construct very small toy experiments

## assays
assays_protein <- list(expression = matrix(1:9, ncol = 3))

## colData
colData <- data.frame(sample = c('A1', 'A2', 'A3'),
                      condition = c('A', 'A', 'A'),
                      time = c(1, 2, 3))
## rowData
rowData_protein <- data.frame(prot_id = LETTERS[1:3])

## construct the ProteinExperiment
protExp <- ProteinExperiment(assays = assays_protein, 
                             rowData = rowData_protein, 
                             colData = colData, 
                             conditionCol = 'condition', 
                             timeCol = 'time')

protExp
```

Here is an example of constructing a `PeptideExperiment`:

```{r}

## assays
assays_peptide <- list(expression = matrix(1:15, ncol = 3))

## colData
colData <- data.frame(sample = c('A1', 'A2', 'A3'),
                      condition = c('A', 'A', 'A'),
                      time = c(1, 2, 3))
## rowData
rowData_peptide <- data.frame(pept_id = letters[1:5], 
                              prot_id = c('A', 'A', 'B', 'C', 'C')) 
## construct the ProteinExperiment
peptExp <- PeptideExperiment(assays = assays_peptide, 
                             rowData = rowData_peptide, 
                             colData = colData, 
                             conditionCol = 'condition', 
                             timeCol = 'time')

peptExp
```

### Accessor functions

The accessor functions are exactly the same as in a `SummarizedExperiment` object, these are mainly: `rowData()`, `colData()`, `assays()` and `metadata()`. To access the `metaoptions` slot the `metaoptions()` function can be used.

```{r}

## assays
assays(protExp)
assays(peptExp)

```

```{r}

## rowData
rowData(protExp)
rowData(peptExp)

```

```{r}

## colData
colData(protExp)
colData(peptExp)

```

```{r}

## metaoptions
metaoptions(protExp)

metaoptions(peptExp)[['proteinCol']] <- 'prot_id'
metaoptions(peptExp)

```

### Subsetting and aggregation

Similarly to the accessor function, most of the `SummarizedExperiment` operations, such as subsetting and aggregating, can be applied to the two classes. For subsetting these are mainly: `[`, `subset()`, `$`; and for aggregation these are mainly: `cbind`, `rbind` and `merge`. For a more detailed explanation please refer to the package manual. 

```{r}

## subsetting by rows and columns
protExp[1, 1:2]
peptExp[1, 1:2]

## subsetting by rows based on rowData
subset(protExp, prot_id == 'A')
subset(peptExp, pept_id %in% c('a', 'b'))

## quick acces to colData
protExp$sample
peptExp$condition

```

```{r}

## combining by columns
cbind(protExp[, 1], protExp[, 2:3])

## combining by rows
rbind(peptExp[1:3, ], peptExp[4:5, ])

## combine rows and columns
merge(peptExp[1:3, 1], peptExp[3:5, 2:3])

```


## `ProteomicsExperiment`

The `ProteomicsExperiment` object contains both a `ProteinExperiment` and a `PeptideExperiment` object. Therefore it can be used to store both levels of information in a single object. The protein and peptide level are aligned/linked by the `colData` slot and by the `linkerDf` slot. The `linkerDf` slot contains a `data.frame` that indicates which indicates which peptides are assigned to each protein and *vice versa*.

### Object construction

To construct a `ProteomicsExperiment` we need at least a `ProteinExperiment` object and a `PeptideExperiment` object.

```{r}

ProteomicsExp <- ProteomicsExperiment(ProteinExperiment = protExp, 
                                      PeptideExperiment = peptExp)

ProteomicsExp

```

In this case, the levels are only aligned by columns. There is no information on which are the relationships between proteins and peptides. This information can be added in the `linkerDf` slot. Which contains a `data.frame` that indicates the relationships between the two levels features. One can be easily constructed with the `buildLinkerDf()` function.

```{r}

## list with the relationships
protein_to_peptide <- list(A = c('a', 'b'), B = c('c'), C = c('d', 'e'))

linkerDf <- buildLinkerDf(protIDs = LETTERS[1:3], 
                          pepIDs  = letters[1:5], 
                          protToPep = protein_to_peptide)

linkerDf

ProteomicsExp <- ProteomicsExperiment(ProteinExperiment = protExp, 
                                      PeptideExperiment = peptExp, 
                                      linkerDf = linkerDf)

```

### Accessor functions

If the slot is general to the `ProteomicsExperiment` object then the same functions as in a `SummarizedExperiment` can be used.

```{r}

## colData
colData(ProteomicsExp)

```


```{r}

## linkerDf
linkerDf(ProteomicsExp)

```

```{r}

## metadata
metadata(ProteomicsExp)

```


```{r}

## metaoptions
metaoptions(ProteomicsExp)

```

But for protein/peptide shared slots names, like `assays` and `rowData`, there are two options to access them. Using the `SummarizedExperiment` generic will return a named list with the two elements.

```{r}

## assays
assays(ProteomicsExp)

```

```{r}

## rowData
rowData(ProteomicsExp)

```

To access specifically a slot of protein or peptide level one can use the same functions and just add `Prot` or `Pept` as suffixes.

```{r}

## assays of protein level
assaysProt(ProteomicsExp)

## assays of peptide level
assaysPept(ProteomicsExp)

```

```{r}

## rowData of protein level
rowDataProt(ProteomicsExp)

## rowData of peptide level
rowDataPept(ProteomicsExp)

```

### Subsetting and aggregation

When subsetting row-wise on a `ProteomicsExperiment` there will be two main questions: 

- To which level is the subset applied?
- Is the subset from one level applied also to the other?

The answer to these questions is written in the `metaoptions` values. The first one is `subsetMode` which can be `protein` or `peptide`. The second one is `linkedSubset`, which can be `TRUE` or `FALSE`. Moreover, if the latter is set to `TRUE` then the `idColProt` and `idColPept` will also be required.

Here are some examples of using the `[` in different situations.

Subset at protein level without affecting the peptide level.

```{r}

## indicate which rowDat columns have unique ids for proteins and peptides
metaoptions(ProteomicsExp)[['idColProt']] <- 'prot_id'
metaoptions(ProteomicsExp)[['idColPept']] <- 'pept_id'
## indicate that we want to apply the subset at protein level
metaoptions(ProteomicsExp)[['subsetMode']] <- 'protein'
## and not extend it to the peptide level
metaoptions(ProteomicsExp)[['linkedSubset']] <- FALSE

ProteomicsExp[1:2,]

```

It can be seen that the protein level has two proteins while the peptide level kept all five peptides.

Subset at protein level and extending the subset to the peptide level.

```{r}
## to extend we set the metaoption to TRUE
metaoptions(ProteomicsExp)[['linkedSubset']] <- TRUE

ProteomicsExp[1:2,]

```

In this case the protein level has two proteins and the peptide level has also been subset to the three peptides that are assigned to the two proteins in the `linkerDf`. 

The same process can also be applied at peptide level.
```{r}
## indicate that we want to apply the subset at protein level
metaoptions(ProteomicsExp)[['subsetMode']] <- 'peptide'
## to extend we set the metaoption to TRUE
metaoptions(ProteomicsExp)[['linkedSubset']] <- TRUE

ProteomicsExp[1:2,]

```
In this case, the first two peptides are selected, these belong to the first protein which is also selected.

Other subset operations can be done using `subsetProt()` and `subsetPep()`, which call the generic `subset()` on the `rowData` slot of the protein and peptide level respectively. Note that `subsetProt()` and `subsetPep()` will behave differently depending on the metaoption `linkedSubset` as seen above with `[`.


```{r}

## without linked Subset
metaoptions(ProteomicsExp)[['linkedSubset']] <- FALSE
subsetProt(ProteomicsExp, prot_id == 'B')

```

```{r}

## with linked Subset
metaoptions(ProteomicsExp)[['linkedSubset']] <- TRUE
subsetProt(ProteomicsExp, prot_id == 'B')

```

Finally for aggregating `cbind`, `rbind` and `merge` can be used.

```{r}

## cbind
cbind(ProteomicsExp[,1], ProteomicsExp[,2])

```

```{r}

## rbind
rbind(ProteomicsExp[1:2,], ProteomicsExp[3,])


```

```{r}

## merge
merge(ProteomicsExp[1:3,1], ProteomicsExp[3:4, 2:3])

```


## `metaoptions`

The `metaoptions` slot contains a `list` with a set of "option" values used to indicate where critical analysis information is required. The idea is that these values are defined at the beginning of the analysis so that it is not required to give them as arguments in each function call. Nevertheless, all the analysis functions can have these values passed as arguments. There are several `metaoptions` values by default, some or them are shared between the three classes while others are unique.

The following are related to data analysis:

- `conditionCol`: which column in `colData` indicates the different experiment conditions.
- `timeCol`: which column in `colData` indicates the different timepoints of the experiment.
- `replicateIntCol`: which column in `colData` indicates expression/intensity replicates.
- `replicateTimeCol`: which column in `colData` indicates timepoint replicates.
- `proteinCol`:  which column in `rowData` indicates the assigned protein to a peptide. (unique to `PeptideExperiment`)

The following are related to `ProteomicsExperiment` subsetting operations:

- `idColProt`: which column in `rowDataProt` indicates unique protein IDs. (unique to `ProteomicsExperiment`)
- `idColPept`: which column in `rowDataPept` indicates unique peptide IDs. (unique to `ProteomicsExperiment`)
- `linkedSubset`: logical that indicates if the subsetting operation should be applied to both data levels (protein and peptide). (unique to `ProteomicsExperiment`)
- `subsetMode`: which level should be used for reference when subsetting (protein or peptide). (unique to `ProteomicsExperiment`)

These can be extended by the user to accomodate other experiment design and data analysis operations.

# Example data

To demonstrate the use of the package functions a reduced version of the pulsed-SILAC dataset from @Visscher2016 has been built into a `ProteomicsExperiment` object. It is stored in an object named `wormsPE`. This object has been constructed from the output files from MaxQuant 'proteinGroups.txt' and 'peptides.txt'.

```{r}

wormsPE

```

The dataset contains only the first 250 proteins and their corresponding peptides. It has already been filtered for possible contaminants and low quality proteins. It has 4 assays with the total intensity, light isotope and heavy isotope intensities and heavy/light isotope ratio. In the experiment there are 2 cell lines: OW40, which express $\alpha$-synuclein-YFP (model for Parkinson's Disease) and OW450, which express YFP only. Worms were harvested after 4h, 6h, 8h, 13h, 24h, 28h and 32h of light to heavy isotope medium transition.


# Filtering

## Measurements across time

To model a protein's turnover several timepoints are required. Ideally a protein would be measured in all the timepoints of the experiment, but this is rarely the case. To count how many proteins/peptides have been measured in each sample the `barplotFeaturesCounts()` can be used.

```{r}

barplotFeaturesCounts(wormsPE, assayName = 'ratio')

```

There is some variability between samples, but more importantly is knowing if the a protein has been measured across different timepoints. The function `barplotTimeCoverage()` can be used to visualize in how many timepoints each protein has been measured per condition.

```{r}

barplotTimeCoverage(wormsPE, assayName = 'ratio')

```

As it can be seen, most of the proteins are not measured at all timepoints. In this case there is a majority for proteins that have not been measured in any timepoint, this is because the dataset has been truncated for only the OW40 and OW450 lines. The original search was one with additional worm lines and these missing proteins are probably detected in the excluded lines.

To filter proteins that have not been detected in enough timepoints the `filterByMissingTimepoints()` function can be used. With `maxMissing` the amount of missing values can be tuned. With `strict` proteins have to meet the maxMissing criteria only in one condition or in all.

```{r}

wormsPE2 <- filterByMissingTimepoints(wormsPE, 
                                      assayName = 'ratio', 
                                      maxMissing = 2, 
                                      strict = FALSE)

barplotTimeCoverage(wormsPE2, assayName = 'ratio')

```

Because `strict` is set to `FALSE`, there are still some proteins that have been detected in less than 5 timepoints in one of the conditions. To visualize the overlap between conditions, the `overlapFeatures()` function can be used. This can be specially useful when more the experiment contains more than two conditions. Here the overlap of proteins is shown.

```{r}

overlapFeatures(wormsPE2@ProteinExperiment, 
                assayName = 'ratio', 
                maxMissing = 2)

```

In this case there are 68 proteins that have been measured in at least 5 out of 7 timepoints in both conditions. These would be proteins for which turnover models can be compared betwee conditions.

Filtering by missing timepoints can also be done at peptide level if desired by changing `subsetMode` to `peptide`.

## Other filters

Other filters can be easily applied using the `subset` method. For example, proteins with a low amount of unique peptides can be filtered out.

```{r, eval = FALSE}

subsetProt(wormsPE, Unique.peptides > 2)

```

Also proteins that are known contaminants or identified using the reverse database.

```{r, eval = FALSE}

subsetProt(wormsPE, Potential.contaminant != '+')
subsetProt(wormsPE, Reverse != '+')


```

# Ratio and fraction calculation

To model protein turnover the isotope fractions at each timepoint are used. The isotope fraction can be calculated in many ways. A simple approach is to derive them from isotope ratios, which many raw mass spectrometry data analysis software report. If not, one can use the `calculateIsotopeRatio()` function, which will add a new assay named `ratio` to the object. In this example, the ratio of newly synthesized protein (heavy isotope) over old protein (light isotope) will be used.

```{r, eval = FALSE}

## calculate the ratio of new istope over old isotope
wormsPE <- calculateIsotopeRatio(x = wormsPE, 
                                 assayNameA = 'int_heavy', 
                                 assayNameB = 'int_light')

```

$$ratio = \frac{isotope_{A}}{isotope_{B}}$$

And then the fraction can be calculated as follows:

$$fraction_{A} = \frac{ratio}{1 + ratio}$$

This can be easily done using the `calculateIsotopeFraction()` function, which adds a new assay named `fraction`. In this case the heavy isotope fraction is calculated, the light isotope fraction would just be 1-fraction<sub>A</sub>. 

```{r, eval = TRUE}

wormsPE <- calculateIsotopeFraction(wormsPE, ratioAssay = 'ratio')

assaysProt(wormsPE)
assaysPept(wormsPE)

```

Unfortunately, this approach might miss some values because of the mass spectrometry nature (bias towards high abundance). For example: if a protein has a very slow turnover rate, it might be that at the earliest timepoint, the new isotope signal was under the detection limit and a ratio could not be calculated. To also account for these proteins the `calculateIsotopeFraction` function has additional arguments to indicate which assays contain each isotope's expression data and which timepoints are considered "early" or "late". 

```{r, eval = FALSE}

wormsPE <- calculateIsotopeFraction(wormsPE, 
                                    newIsoAssay = 'int_heavy',
                                    oldIsoAssay = 'int_light',
                                    earlyTimepoints = 1,
                                    lateTimepoints = 7)

```


# Model protein turnover

To estimate protein turnover rate the `modelTurnover()` function can be used. Parameter fitting is done using the `nls` function, or the `nlrob` function from `robustbase` for robust modelling. The `formula`, `start` and `...` arguments are passed into these functions. By default an exponential decay model is used, but it has been shown that some proteins do not follow such model @McShane2016.

```{r, warning = FALSE}

modelList <- modelTurnover(x = wormsPE, 
                           assayName = 'fraction',
                           formula = 'fraction ~ 1 - exp(-k*t)',
                           start = list(k = 0.02),
                           mode = 'protein',
                           returnModel = TRUE)

```

## Output of `modelTurnover()`

The output of `modelTurnover()` is a list with the main model metrics: 

- `residuals`: a matrix of the same dimensions as `x` with the model residuals.
- `stderror`: a matrix with the standard error of each model.
- `param_values`: a matrix with the estimated parameter values of each model.
- `param_pval`: a matrix with the p-value of each parameter of each model.
- `param_tval`: a matrix with the t-statistic of each parameter of each model.
- `param_stderror`: a matrix with the standard error of each parameter of each model.

It is not rare that a model fails to converge, failed models have `NA` as their output metrics. 

There are more options to tune `modelTurnover()`, such as: `robust`, to use robust modelling; `returnModel`, which will return the actual model objects instead of the metrics; `verbose`, to output a progress bar. For more information please refer to the manual.

## Plots

The output of `modelTurnover()` with `returnModel = TRUE` can be used as input in the following functions to plot either individual protein/peptides models or the overall experiment distributions. 

All the following function return objects of class `ggplot`, therefore their theme, scale, labels, etc. can be customized after the function call. Furthermore, if the argument `return` is set to `data.frame`, the `data.frame` used in the plot function will be returned instead.

### Individual models

To plot individual models the `plotIndividualModel()` method can be used. As input it requires the object that was used in the `modelTurnover()` call, it cam be a `ProteinExperiment`, `PeptideExperiment` or a `ProteomicsExperiment` object; it also requires the output from the `modelTurnover()` call and a number indicating which model should be plotted.

```{r, warning = FALSE}

modelList <- modelTurnover(x = wormsPE, 
                           assayName = 'fraction',
                           formula = 'fraction ~ 1 - exp(-k*t)',
                           start = list(k = 0.02),
                           mode = 'protein', 
                           returnModel = TRUE)

plotIndividualModel(x = wormsPE, 
                    modelList = modelList, 
                    num = 2)

```

The plot shows the actual values as dots and the fitted model as a curve. If the models are based on grouped peptide data then the values of each peptide are plotted as dots. Here is an example.

```{r, warning = FALSE}

## to indicate which column of rowDataPept indicates the assigned protein
metaoptions(wormsPE)[['proteinCol']] <- 'Protein.group.IDs'
modelList <- modelTurnover(x = wormsPE, 
                           assayName = 'fraction',
                           formula = 'fraction ~ 1 - exp(-k*t)',
                           start = list(k = 0.02),
                           mode = 'grouped', 
                           returnModel = TRUE)

plotIndividualModel(x = wormsPE, 
                    modelList = modelList, 
                    num = 2)

```

### Distributions

It can be interesting also to plot the overall distributions of the model metrics per condition. This can show global changes between conditions and/or can be used for quality control. 
Some metrics that might be interesting to check are the R<sup>2</sup> error of the models, the estimated parameters, the residuals and the weights (only for robust modelling).

In this case, both the outputs of `modelTurnover()` with `returnModel = TRUE` or with `returnModel = FALSE` will work.

#### R<sup>2</sup> error


```{r, eval = TRUE, include = FALSE, warning = FALSE}
modelList <- modelTurnover(x = wormsPE, 
                           assayName = 'fraction',
                           formula = 'fraction ~ 1 - exp(-k*t)',
                           start = list(k = 0.02),
                           mode = 'peptide', 
                           robust = FALSE,
                           returnModel = FALSE)

```

This plot shows the distribution of the error of all the models for each condition.

```{r, warning = FALSE}

plotDistribution(x = wormsPE, 
                 modelList = modelList,
                 value = 'error',
                 plotType = 'density')

```

#### Turnover rate

This plot shows the distribution of the values for every fitted parameter. In this case there is only one: 'k', the turnover rate.

```{r, warning = FALSE}

plotDistribution(x = wormsPE, 
                 modelList = modelList,
                 value = 'parameter',
                 plotType = 'density')

```

#### Residuals

This plot shows the distribution of residuals at each timepoint for each condition.

```{r, warning = FALSE}

plotDistribution(x = wormsPE, 
                 modelList = modelList,
                 value = 'residuals',
                 plotType = 'density')

```

#### Weights

This plot shows the distribution of weights at each timepoint for each condition. This is only available if robust modelling is used.

```{r, warning = FALSE}

plotDistribution(x = wormsPE, 
                 modelList = modelList,
                 value = 'weights',
                 plotType = 'density')

```

## Comparing models

It might be that some proteins follow a specific turnover model, while other follow a different one. In that case, one can run `modelTurnover()` for each different model and then compare the models for each protein. One metric often used to compare models is the Akaike Information Criteria (AIC). It can be calculated using the `calculateAIC()` function. Afterwards the probability of each model relative to the rest can be calculated with the `compareAIC()` function.


# Cell growth estimation

During most pulsed-SILAC experiment cells will keep dividing. This means that protein synthesis will be greater than protein degradation. When comparing conditions in which cells divide at similar rates this effect might not be a problem. But if cell growth is different between conditions then steady-state protein turnover will be ofuscated by the difference in protein synthesis due to cell growth.

This issue can be corrected by using a turnover model which takes cell growth into consideration. For example in exponential degradation (where t<sub>cc</sub> is the cell division average time):

$$f(H) = 1 - e^{-(k + \frac{log 2}{t_{cc}})t}$$

If this information is not available, the `estimateCellGrowth()` function can be used. This function will fit an exponential degradation model based on the `n` most stable proteins (proteins which are measured in all time points and have the slowest new isotope incorporation). 


For the current dataset, cell division was not an issue since adult worms do no longer divide. To illustrate the effects of cell growth we will use data of mouse embryonic fibroblasts (MEFs) cultured in two medium conditions: with and without serum. MEFs that are cultured with serum will grow at a "normal" rate while MEFs cultured without serum will grow at a neglegible rate. This can be seen in the heavy fraction over time plot.


# Isotope recycling estimation

# Further analysis

## Gene set/pathway enrichment analysis

## Differential expression analysis

# Session info

```{r}
sessionInfo()
```
